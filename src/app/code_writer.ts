// Writes the assembly code that implements the parsed command

//   0 - 15   – Virtual Registers
//  16 - 255  – Static Variables
// 256 - 2047 – Stack

/*
SP:   RAM[0] Stack pointer
LCL:  RAM[1] Base address of the local segment
ARG:  RAM[2] Base address of argument segment
THIS: RAM[3] Base address of the this segment
THAT: RAM[4] Base address of the that segment
TEMP: RAM[5-12] Holds the temp segment
R13,
R14,  RAM[13-15] If the assembly code generated by the VM translator needs
R15              variables, it can use these register
*/

const REGISTERS = {
  stackPointer: "SP",
  local: "LCL",
  argument: "ARG",
  this: "THIS",
  that: "THAT",
  temp: "TEMP",
  R13: "R13",
  R14: "R14",
  R15: "R15",
} as const;

import * as multiline from "@utils/multiline.ts";

import * as parser from "./parser.ts";

export function writeCommand(
  parsedCommand:
    | parser.ArithmeticOrLogicalCommandResult
    | parser.PushOrPopCommandResult,
) {
  const { command } = parsedCommand;

  if (command === "push" || command === "pop") {
    return handlePushOrPopCommand(parsedCommand);
  }

  if (command === "add") {
    return multiline.stripIndent`
      // add
      @SP
      AM=M-1
      D=M
      A=A-1
      M=D+M
    `;
  }

  if (command === "sub") {
    return multiline.stripIndent`
      // sub
      @SP
      AM=M-1
      D=M
      A=A-1
      M=M-D
    `;
  }

  if (command === "neg") {
    return multiline.stripIndent`
      // neg
      // pop off stack
      @SP
      // pop off stack (SP--)
      M=M-1
      A=M
      D=M
      @R13 // Store this temporarily
      M=D
      // do -M operation and store it in D
      @R13
      D=-M
      // push it back onto the stack
      @SP
      A=M
      M=D
      @SP
      M=M+1
    `;
  }

  /*
  "eq",
  "gt",
  "lt",
  "and",
  "or",
  "not",
  */

  return `// ${command}`;
}

function handlePushOrPopCommand(parsedCommand: parser.PushOrPopCommandResult) {
  const { command, segment, value } = parsedCommand;

  if (command === "push") {
    if (segment === "constant") {
      return multiline.stripIndent`
        // ${command} ${segment} ${value}
        @${value}
        D=A
        @${REGISTERS.stackPointer}
        A=M
        M=D
        @${REGISTERS.stackPointer}
        M=M+1
      `;
    }

    if (segment === "pointer") {
      if (value !== 0 && value !== 1) {
        throw new Error(
          `Value must equal 0 or 1, to correspond to 'THIS' or 'THAT'. Was: ${value}`,
        );
      }

      const valueSymbol = value === 0 ? REGISTERS.this : REGISTERS.that;

      return multiline.stripIndent`
        // ${command} ${segment} ${value}
        @${valueSymbol}
        D=M
        @${REGISTERS.stackPointer}
        A=M
        M=D
        @${REGISTERS.stackPointer}
        M=M+1
      `;
    }
  }

  throw new Error(
    `Unhandled command: ${JSON.stringify(parsedCommand, null, 2)}`,
  );
}
